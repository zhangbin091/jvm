#第三章垃圾收集器与内存分配策略

##3.1概述
1、哪些内存需要回收？  
2、什么时候回收？  
3、怎么回收内存？
程序计数器、虚拟机栈、本地方法栈这三个部分随线程生死，不需要进行垃圾回收，堆和方法区需要进行垃圾回收，只有在程序运行时才知道分配的内存大大小。
##3.2对象已死吗

###3.2.1引用计数算法
判断一个对象是否失效，有一个地方引用他，计数加1；当引用失效，计数器减1.任何计数器为0的对象不可能再被使用。  
无法解决对象之间相互引用问题。 
###3.2.2可达性分析算法
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Root没有任何引用链相连时，则此对象不可用的。  
可作为GC Root的对象：  
虚拟机栈中引用的对象，方法区中类静态属性引用的对象；方法区中常量引用的对象，本地方法栈中JNI引用的对象。


###3.2.3再谈引用
强引用、软引用、弱引用、虚引用


###3.2.4生产还是死亡
判断一个对象是否死亡，经历两次标记过程：1、可达性分析中未与GC Root引用链，第一次标记，并且进行第一次筛选，筛选的条件是此对象是否有必要执行finalize()方法；当对象没有覆盖finalize()方法，或者finalize（）已经被虚拟机调用，则没有必要执行；当有必要执行时，将该对象放在一个F-Queue队列中，并由finalizer()线程去执行它

###3.2.5回收方法区



##3.3垃圾收集算法


###3.3.1标记-清除算法



###3.3.2复制算法



###3.3.3标记-整理算法



###3.3.4分代收集算法


##3.4HotSpot的算法实现


###3.4.1枚举根节点

###3.4.2安全点


###3.4.3安全区域



##3.5垃圾收集器


###3.5.1serial收集器


###3.5.2ParNew收集器




###3.5.3Parallel Scavenge收集器


###3.5.4Serial Old 收集器


###3.5.5Parallel Old收集器



###3.5.6CMS收集器


###3.5.7G1收集器



###3.5.8理解GC日志


###3.5.9垃圾收集器参数总结


##3.6内存分配与回收策略



###3.6.1对象优先在Eden分配




###3.6.2大对象直接进入老年代


###3.6.3长期存活的对象将进入老年代


###3.6.4动态对象年龄判定


###3.6.5空间分配担保





















































