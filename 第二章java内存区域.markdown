#第二章 Java内存区域与内存溢出异常

##2.2运行时数据区域
java虚拟机在执行java程序时管理的内存区域

###2.2.1程序计数器
当前线程所执行的字节码行号指示器，每个线程都有一个自己的程序计数器，记录字节码解释器下一条指令位置。

###2.2.2Java虚拟机栈
线程私有，描述的是java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态链表、方法出口等信息。

###2.2.3本地方法栈
为虚拟机使用到的native方法服务。
注：本地方法指的是用非java语言实现的方法
###2.2.4Java堆
被所有线程公用的一块内存区域，存放对象实例(包含数组)，垃圾收集器管理的主要区域。  

新生代：  
老生代：

Eden空间、from survior空间、to survior空间等

###2.2.5方法区
各个线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后打代码等数据。  
永久代

###2.2.6运行时常量池
方法区的一部分，用于存放编译期生成的各个字面量和符号引用（类的符号引用）

###2.2.7直接内存

##2.3HotSpot虚拟机对象探秘
###2.3.1对象的创建
1）检查new指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，执行相应的加载过程。  
2）为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，（在java堆中确定一块内存）。内存分配方式：  
指针碰撞：堆内存规整的，使用的内存放一边，未使用的内存放一边，中间放着一个指针作为指示器，分配内存就是把指针向空闲内存移动确定大小内存。带规整的垃圾收集器，serial、ParNew等    
空闲列表：使用过的内存与未使用的内存杂乱的，虚拟机维护一个列表，记录哪些内存已经可用。  
多线程创建对象导致的不安全解决方案：  
1.对分配内存空间的动作进行同步处理；  
2.内存分配的动作按照线程划分在不同的空间进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），可通过-xx:+/-UseTLAB参数设定。  
3）内存分配完成后，虚拟机啊将分配的内存空间初始化为零值；  
4）虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希吗，对象的gc分代年龄等信息。  
5）执行new指令之后，会进行init方法，把对象按照程序员的医院进行初始化。


###2.3.2对象的内存布局
分为对象头（Header）、实例数据（Instance Data）、对其填充（Padding）  
1、对象头  
a,存储对象本身的运行时数据：如哈希吗、gc分代年龄、锁状态标志、线程持有的锁等。  
b,类型指针：即对象指向它的类元数据的指针，确定这个对象是哪个类的实例。  
如果对象是是一个java数组，那么对象头中还必须有一个记录数组长度的数据  
2、实例数据  
对象真正存储的有效信息，程序代码中所定义的各种类型的字段内容。存储顺序受到虚拟机内存分配策略参数和字段在java源码中的定义顺序的影响。相同宽度的字段总是放在一起。  
3、对其填充  
Hotspot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，对象的大小必须是8字节的整数倍





###2.3.3对象的访问定位
通过栈上的reference数据来操作堆上的具体对象。
1、句柄访问  
java堆中划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含对象实例数据与类型数据各自的具体地址信息  
2、直接指针访问
reference中存储的直接就是对象地址
##2.4实战：OutOfMemoryError异常
###2.4.1java堆溢出


###2.4.2虚拟机栈和本地方法栈溢出



###2.4.3方法区和运行时常量池溢出


###2.4.4本地直接内存溢出 
